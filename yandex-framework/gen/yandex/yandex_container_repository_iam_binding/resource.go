// Code generated by tfgen. DO NOT EDIT.

package yandex_container_repository_iam_binding

import (
	"context"
	"fmt"
	"strings"
	"time"

	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"
	"github.com/yandex-cloud/go-genproto/yandex/cloud/access"
	containerregistryv1sdk "github.com/yandex-cloud/go-sdk/services/containerregistry/v1"
	globallock "github.com/yandex-cloud/terraform-provider-yandex/common/mutexkv"
	accessbinding "github.com/yandex-cloud/terraform-provider-yandex/pkg/iam_access"
	provider_config "github.com/yandex-cloud/terraform-provider-yandex/yandex-framework/provider/config"
	"google.golang.org/grpc"
	"google.golang.org/grpc/metadata"
)

const (
	defaultPageSize = 1000
	defaultTimeout  = 5 * time.Minute
)

type iamPolicyModifyFunc func(p *accessbinding.Policy) error

var mutexKV = globallock.NewMutexKV()

type IAMUpdater struct {
	repositoryId   string
	providerConfig *provider_config.Config
}

func NewResource() resource.Resource {
	return &IAMUpdater{}
}

func (u *IAMUpdater) Schema(_ context.Context, _ resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		MarkdownDescription: "Allows creation and management of a single binding within IAM policy for an existing `repository`.",
		Attributes: map[string]schema.Attribute{
			"role": schema.StringAttribute{
				MarkdownDescription: "The role that should be assigned. Only one yandex_container_repository_iam_binding can be used per role.",
				Required:            true,
			},
			"members": schema.SetAttribute{
				MarkdownDescription: "An array of identities that will be granted the privilege in the `role`. Each entry can have one of the following values:\n * **userAccount:{user_id}**: A unique user ID that represents a specific Yandex account.\n * **serviceAccount:{service_account_id}**: A unique service account ID.\n * **federatedUser:{federated_user_id}**: A unique federated user ID.\n * **federatedUser:{federated_user_id}:**: A unique SAML federation user account ID.\n * **group:{group_id}**: A unique group ID.\n * **system:group:federation:{federation_id}:users**: All users in federation.\n * **system:group:organization:{organization_id}:users**: All users in organization.\n * **system:allAuthenticatedUsers**: All authenticated users.\n * **system:allUsers**: All users, including unauthenticated ones.\n\n~> for more information about system groups, see [Cloud Documentation](https://yandex.cloud/docs/iam/concepts/access-control/system-group).\n\n",
				Required:            true,
				ElementType:         types.StringType,
			},
			"repository_id": schema.StringAttribute{
				MarkdownDescription: "The ID of the compute `repository` to attach the policy to.",
				Required:            true,
			},
			"sleep_after": schema.Int64Attribute{
				MarkdownDescription: "For test purposes, to compensate IAM operations delay",
				Optional:            true,
			},
		},
	}
}

func (u *IAMUpdater) Initialize(ctx context.Context, state accessbinding.Extractable, diag *diag.Diagnostics) {
	var id types.String

	diag.Append(state.GetAttribute(ctx, path.Root("repository_id"), &id)...)
	u.repositoryId = id.ValueString()
}

func (r *IAMUpdater) Metadata(_ context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = "yandex_container_repository_iam_binding"
}

func (u *IAMUpdater) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	providerConfig, ok := req.ProviderData.(*provider_config.Config)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *provider_config.Config, got: %T. "+
				"Please report this issue to the provider developers.", req.ProviderData),
		)
		return
	}

	u.providerConfig = providerConfig
}

func (r *IAMUpdater) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	idParts := strings.Split(req.ID, ",")

	if len(idParts) != 2 || idParts[0] == "" || idParts[1] == "" {
		resp.Diagnostics.AddError(
			"Unexpected Import Identifier",
			fmt.Sprintf("Expected import identifier with format: {resource_id},{role}. Got: %q", req.ID),
		)
		return
	}

	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("repository_id"), idParts[0])...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("role"), idParts[1])...)
}

func (u *IAMUpdater) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	ctx, cancel := context.WithTimeout(ctx, defaultTimeout)
	defer cancel()

	u.Initialize(ctx, req.Plan, &resp.Diagnostics)
	if resp.Diagnostics.HasError() {
		return
	}

	policies := accessbinding.GetResourceIamBindingsFromState(ctx, req.Plan, &resp.Diagnostics)
	err := u.iamPolicyReadModifySet(ctx, u, func(ep *accessbinding.Policy) error {
		// Creating a binding does not remove existing members if they are not in the provided members list.
		// This prevents removing existing permission without the user's knowledge.
		// Instead, a diff is shown in that case after creation. Subsequent calls to update will remove any
		// existing members not present in the provided list.
		ep.Bindings = accessbinding.MergeBindings(append(ep.Bindings, policies...))
		return nil
	})
	if err != nil {
		resp.Diagnostics.AddError(
			"Unable to Attach Resource Policies",
			fmt.Sprintf("An unexpected error occurred while attempting to attach resource policies"+
				"Please retry the operation or report this issue to the provider developers.\n\n"+
				"Error: %s", err),
		)
		return
	}

	var sleep types.Int64
	req.Plan.GetAttribute(ctx, path.Root("sleep_after"), &sleep)
	if !sleep.IsNull() && !sleep.IsUnknown() {
		time.Sleep(time.Second * time.Duration(sleep.ValueInt64()))
	}

	u.refreshBindingState(ctx, req.Plan, &resp.State, &resp.Diagnostics)
}

func (u *IAMUpdater) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	ctx, cancel := context.WithTimeout(ctx, defaultTimeout)
	defer cancel()

	u.Initialize(ctx, req.State, &resp.Diagnostics)
	if resp.Diagnostics.HasError() {
		return
	}

	u.refreshBindingState(ctx, req.State, &resp.State, &resp.Diagnostics)
}

func (u *IAMUpdater) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	ctx, cancel := context.WithTimeout(ctx, defaultTimeout)
	defer cancel()

	u.Initialize(ctx, req.Plan, &resp.Diagnostics)
	bindings := accessbinding.GetResourceIamBindingsFromState(ctx, req.Plan, &resp.Diagnostics)

	var stateRole types.String
	resp.Diagnostics.Append(req.State.GetAttribute(ctx, path.Root("role"), &stateRole)...)

	err := u.iamPolicyReadModifySet(ctx, u, func(p *accessbinding.Policy) error {
		p.Bindings = accessbinding.RemoveRoleFromBindings(stateRole.ValueString(), p.Bindings)
		p.Bindings = append(p.Bindings, bindings...)
		return nil
	})
	if err != nil {
		resp.Diagnostics.AddError(
			"Unable to Update Resource Policies",
			fmt.Sprintf("An unexpected error occurred while updating resource policies"+
				"Please retry the operation or report this issue to the provider developers.\n\n"+
				"Error: %s", err))
		return
	}

	u.refreshBindingState(ctx, req.Plan, &resp.State, &resp.Diagnostics)
}

func (u *IAMUpdater) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	ctx, cancel := context.WithTimeout(ctx, defaultTimeout)
	defer cancel()

	u.Initialize(ctx, req.State, &resp.Diagnostics)
	binding := accessbinding.GetResourceIamBindingsFromState(ctx, req.State, &resp.Diagnostics)
	if len(binding) == 0 {
		tflog.Debug(ctx,
			fmt.Sprintf(
				"Resource yandex_container_repository_iam_binding '%s' is missing or deleted, marking policy binding as deleted",
				u.repositoryId,
			),
		)
		return
	}
	role := binding[0].RoleId

	err := u.iamPolicyReadModifySet(ctx, u, func(p *accessbinding.Policy) error {
		p.Bindings = accessbinding.RemoveRoleFromBindings(role, p.Bindings)
		return nil
	})
	if err != nil {
		resp.Diagnostics.AddError(
			"Unable to Delete Resource Policies",
			fmt.Sprintf("An unexpected error occurred while deleting resource policies"+
				"Please retry the operation or report this issue to the provider developers.\n\n"+
				"Error: %s", err))
		return
	}

	u.refreshBindingState(ctx, req.State, &resp.State, &resp.Diagnostics)
}

func (u *IAMUpdater) GetResourceIamPolicy(ctx context.Context) (*accessbinding.Policy, error) {
	var bindings []*access.AccessBinding
	pageToken := ""

	for {
		md := new(metadata.MD)
		resp, err := containerregistryv1sdk.NewRepositoryClient(u.providerConfig.SDKv2).ListAccessBindings(ctx, &access.ListAccessBindingsRequest{
			ResourceId: u.repositoryId,
			PageSize:   defaultPageSize,
			PageToken:  pageToken,
		}, grpc.Header(md))
		if err != nil {
			return nil, err
		}
		if traceHeader := md.Get("x-server-trace-id"); len(traceHeader) > 0 {
			tflog.Debug(ctx, "List yandex_container_repository_iam_binding trace header", map[string]interface{}{
				"x-server-trace-id": traceHeader[0],
			})
		}
		if traceHeader := md.Get("x-server-request-id"); len(traceHeader) > 0 {
			tflog.Debug(ctx, "List yandex_container_repository_iam_binding request header", map[string]interface{}{
				"x-server-request-id": traceHeader[0],
			})
		}

		bindings = append(bindings, resp.AccessBindings...)

		if resp.NextPageToken == "" {
			break
		}

		pageToken = resp.NextPageToken
	}

	return &accessbinding.Policy{Bindings: bindings}, nil
}

func (u *IAMUpdater) SetResourceIamPolicy(ctx context.Context, policy *accessbinding.Policy) error {
	req := &access.SetAccessBindingsRequest{
		ResourceId:     u.repositoryId,
		AccessBindings: policy.Bindings,
	}

	md := new(metadata.MD)
	ctx, cancel := context.WithTimeout(ctx, defaultTimeout)
	defer cancel()

	op, err := containerregistryv1sdk.NewRepositoryClient(u.providerConfig.SDKv2).SetAccessBindings(ctx, req, grpc.Header(md))
	if err != nil {
		return fmt.Errorf("error setting access bindings of yandex_container_repository_iam_binding '%s': %w", u.repositoryId, err)
	}

	_, err = op.Wait(ctx)
	if err != nil {
		return fmt.Errorf("error setting access bindings of yandex_container_repository_iam_binding '%s': %w", u.repositoryId, err)
	}

	return nil
}

func (u *IAMUpdater) UpdateResourceIamPolicy(ctx context.Context, policy *accessbinding.PolicyDelta) error {
	var (
		bSize  = defaultPageSize
		deltas = policy.Deltas
		dLen   = len(deltas)
	)

	for i := 0; i < accessbinding.CountBatches(dLen, bSize); i++ {
		req := &access.UpdateAccessBindingsRequest{
			ResourceId:          u.repositoryId,
			AccessBindingDeltas: deltas[i*bSize : min((i+1)*bSize, dLen)],
		}

		op, err := containerregistryv1sdk.NewRepositoryClient(u.providerConfig.SDKv2).UpdateAccessBindings(ctx, req)
		if err != nil {
			return fmt.Errorf("error updating access bindings of yandex_container_repository_iam_binding '%s': %w", u.repositoryId, err)
		}

		_, err = op.Wait(ctx)
		if err != nil {
			return fmt.Errorf("error updating access bindings of yandex_container_repository_iam_binding '%s': %w", u.repositoryId, err)
		}
	}

	return nil
}

func (u *IAMUpdater) refreshBindingState(ctx context.Context, req accessbinding.Extractable, resp accessbinding.Settable, diag *diag.Diagnostics) {
	var role types.String
	diag.Append(req.GetAttribute(ctx, path.Root("role"), &role)...)

	eBindings := accessbinding.GetResourceIamBindingsFromState(ctx, req, diag)

	policy, err := u.GetResourceIamPolicy(ctx)
	if err != nil {
		diag.AddError(
			"Unable to Refresh Resource Policies",
			fmt.Sprintf("An unexpected error occurred while refreshing resource policies"+
				"Please retry the operation or report this issue to the provider developers.\n\n"+
				"Error: %s", err))
		return
	}
	tflog.Debug(ctx, fmt.Sprintf("Retrieved access bindings of yandex_container_repository_iam_binding '%s': %+v", u.repositoryId, policy))

	var mBindings []*access.AccessBinding
	for _, b := range policy.Bindings {
		if b.RoleId != role.ValueString() {
			continue
		}
		if len(eBindings) != 0 {
			for _, e := range eBindings {
				if accessbinding.CanonicalMember(e) != accessbinding.CanonicalMember(b) {
					continue
				}
				mBindings = append(mBindings, b)
			}
		} else {
			mBindings = append(mBindings, b)
		}
	}

	if len(mBindings) == 0 {
		diag.AddWarning(
			"Empty resource binding",
			fmt.Sprintf("Resource binding for role %q not found, removing from state file.", role))
		resp.RemoveResource(ctx)
		return
	}

	mBindingsSet, diags := types.SetValueFrom(ctx, types.StringType, accessbinding.RoleToMembersList(role.ValueString(), mBindings))
	diag.Append(diags...)
	diag.Append(resp.SetAttribute(ctx, path.Root("members"), mBindingsSet)...)
	diag.Append(resp.SetAttribute(ctx, path.Root("role"), role)...)
	diag.Append(resp.SetAttribute(ctx, path.Root("repository_id"), u.repositoryId)...)
	var sleep types.Int64
	req.GetAttribute(ctx, path.Root("sleep_after"), &sleep)
	diag.Append(resp.SetAttribute(ctx, path.Root("sleep_after"), sleep)...)
}

func (u *IAMUpdater) iamPolicyReadModifySet(ctx context.Context, updater accessbinding.ResourceIamUpdater, modify iamPolicyModifyFunc) error {
	mutexKV.Lock(fmt.Sprintf("yandex_container_repository_iam_binding-%s", u.repositoryId))
	defer mutexKV.Unlock(fmt.Sprintf("yandex_container_repository_iam_binding-%s", u.repositoryId))
	tflog.Debug(ctx, fmt.Sprintf("Retrieving access bindings for yandex_container_repository_iam_binding '%s'", u.repositoryId))

	p, err := updater.GetResourceIamPolicy(ctx)
	if err != nil {
		return err
	}
	tflog.Debug(ctx, fmt.Sprintf("Retrieved access bindings for yandex_container_repository_iam_binding '%s': %+v\n", u.repositoryId, p))

	err = modify(p)
	if err != nil {
		return err
	}
	tflog.Debug(ctx, fmt.Sprintf("Setting access bindings for yandex_container_repository_iam_binding '%s' to %+v", u.repositoryId, p))

	err = updater.SetResourceIamPolicy(ctx, p)
	if err != nil {
		return fmt.Errorf("Error applying access bindings to yandex_container_repository_iam_binding '%s': %w", u.repositoryId, err)
	}
	tflog.Debug(ctx, fmt.Sprintf("Set policy for yandex_container_repository_iam_binding '%s'", u.repositoryId))

	return nil
}
