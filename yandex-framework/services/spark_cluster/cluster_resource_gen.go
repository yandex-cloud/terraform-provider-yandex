// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package spark_cluster

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework-timeouts/resource/timeouts"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/setplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func ClusterResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"config": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"dependencies": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"deb_packages": schema.SetAttribute{
								ElementType:         types.StringType,
								Optional:            true,
								Computed:            true,
								Description:         "Deb-packages that need to be installed using system package manager.",
								MarkdownDescription: "Deb-packages that need to be installed using system package manager.",
								Default:             stringSetDefault(),
							},
							"pip_packages": schema.SetAttribute{
								ElementType:         types.StringType,
								Optional:            true,
								Computed:            true,
								Description:         "Python packages that need to be installed using pip (in pip requirement format).",
								MarkdownDescription: "Python packages that need to be installed using pip (in pip requirement format).",
								Default:             stringSetDefault(),
							},
						},
						CustomType: DependenciesType{
							ObjectType: types.ObjectType{
								AttrTypes: DependenciesValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Computed:            true,
						Description:         "Environment dependencies.",
						MarkdownDescription: "Environment dependencies.",
						Default:             dependenciesDefault(),
					},
					"history_server": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"enabled": schema.BoolAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "Enable Spark History Server. Default: true.",
								MarkdownDescription: "Enable Spark History Server. Default: true.",
								Default:             booldefault.StaticBool(true),
							},
						},
						CustomType: HistoryServerType{
							ObjectType: types.ObjectType{
								AttrTypes: HistoryServerValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Computed:            true,
						Description:         "History Server configuration.",
						MarkdownDescription: "History Server configuration.",
						Default:             historyServerDefault(),
					},
					"metastore": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"cluster_id": schema.StringAttribute{
								Optional:            true,
								Description:         "Metastore cluster ID for default spark configuration.",
								MarkdownDescription: "Metastore cluster ID for default spark configuration.",
							},
						},
						CustomType: MetastoreType{
							ObjectType: types.ObjectType{
								AttrTypes: MetastoreValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Computed:            true,
						Description:         "Metastore configuration.",
						MarkdownDescription: "Metastore configuration.",
						Default:             metastoreDefault(),
					},
					"resource_pools": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"driver": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"max_size": schema.Int64Attribute{
										Optional:            true,
										Description:         "Maximum node count for the driver pool with autoscaling.",
										MarkdownDescription: "Maximum node count for the driver pool with autoscaling.",
									},
									"min_size": schema.Int64Attribute{
										Optional:            true,
										Description:         "Minimum node count for the driver pool with autoscaling.",
										MarkdownDescription: "Minimum node count for the driver pool with autoscaling.",
									},
									"resource_preset_id": schema.StringAttribute{
										Required:            true,
										Description:         "Resource preset ID for the driver pool.",
										MarkdownDescription: "Resource preset ID for the driver pool.",
									},
									"size": schema.Int64Attribute{
										Optional:            true,
										Description:         "Node count for the driver pool with fixed size.",
										MarkdownDescription: "Node count for the driver pool with fixed size.",
									},
								},
								CustomType: DriverType{
									ObjectType: types.ObjectType{
										AttrTypes: DriverValue{}.AttributeTypes(ctx),
									},
								},
								Required:            true,
								Description:         "Computational resources for the driver pool.",
								MarkdownDescription: "Computational resources for the driver pool.",
							},
							"executor": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"max_size": schema.Int64Attribute{
										Optional:            true,
										Description:         "Maximum node count for the executor pool with autoscaling.",
										MarkdownDescription: "Maximum node count for the executor pool with autoscaling.",
									},
									"min_size": schema.Int64Attribute{
										Optional:            true,
										Description:         "Minimum node count for the executor pool with autoscaling.",
										MarkdownDescription: "Minimum node count for the executor pool with autoscaling.",
									},
									"resource_preset_id": schema.StringAttribute{
										Required:            true,
										Description:         "Resource preset ID for the executor pool.",
										MarkdownDescription: "Resource preset ID for the executor pool.",
									},
									"size": schema.Int64Attribute{
										Optional:            true,
										Description:         "Node count for the executor pool with fixed size.",
										MarkdownDescription: "Node count for the executor pool with fixed size.",
									},
								},
								CustomType: ExecutorType{
									ObjectType: types.ObjectType{
										AttrTypes: ExecutorValue{}.AttributeTypes(ctx),
									},
								},
								Required:            true,
								Description:         "Computational resources for the executor pool.",
								MarkdownDescription: "Computational resources for the executor pool.",
							},
						},
						CustomType: ResourcePoolsType{
							ObjectType: types.ObjectType{
								AttrTypes: ResourcePoolsValue{}.AttributeTypes(ctx),
							},
						},
						Required:            true,
						Description:         "Computational resources.",
						MarkdownDescription: "Computational resources.",
					},
				},
				CustomType: ConfigType{
					ObjectType: types.ObjectType{
						AttrTypes: ConfigValue{}.AttributeTypes(ctx),
					},
				},
				Required:            true,
				Description:         "Configuration of the Spark cluster.",
				MarkdownDescription: "Configuration of the Spark cluster.",
			},
			"created_at": schema.StringAttribute{
				Computed:            true,
				Description:         "The timestamp when the cluster was created.",
				MarkdownDescription: "The timestamp when the cluster was created.",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"deletion_protection": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "The `true` value means that resource is protected from accidental deletion.",
				MarkdownDescription: "The `true` value means that resource is protected from accidental deletion.",
				Default:             booldefault.StaticBool(false),
			},
			"description": schema.StringAttribute{
				Optional:            true,
				Description:         "Description of the cluster. 0-256 characters long.",
				MarkdownDescription: "Description of the cluster. 0-256 characters long.",
			},
			"folder_id": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "ID of the cloud folder that the cluster belongs to.",
				MarkdownDescription: "ID of the cloud folder that the cluster belongs to.",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
					stringplanmodifier.RequiresReplace(),
				},
			},
			"health": schema.StringAttribute{
				Computed:            true,
				Description:         "Aggregated health of the cluster.",
				MarkdownDescription: "Aggregated health of the cluster.",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"id": schema.StringAttribute{
				Computed:            true,
				Description:         "Unique ID of the cluster.",
				MarkdownDescription: "Unique ID of the cluster.",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"labels": schema.MapAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Description:         "Cluster labels as key/value pairs.",
				MarkdownDescription: "Cluster labels as key/value pairs.",
			},
			"logging": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"enabled": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Enable log delivery to Cloud Logging. Default: true.",
						MarkdownDescription: "Enable log delivery to Cloud Logging. Default: true.",
						Default:             booldefault.StaticBool(true),
					},
					"folder_id": schema.StringAttribute{
						Optional:            true,
						Description:         "Logs will be written to **default log group** of specified folder. Exactly one of the attributes `folder_id` or `log_group_id` should be specified.",
						MarkdownDescription: "Logs will be written to **default log group** of specified folder. Exactly one of the attributes `folder_id` or `log_group_id` should be specified.",
					},
					"log_group_id": schema.StringAttribute{
						Optional:            true,
						Description:         "Logs will be written to the **specified log group**. Exactly one of the attributes `folder_id` or `log_group_id` should be specified.",
						MarkdownDescription: "Logs will be written to the **specified log group**. Exactly one of the attributes `folder_id` or `log_group_id` should be specified.",
					},
				},
				CustomType: LoggingType{
					ObjectType: types.ObjectType{
						AttrTypes: LoggingValue{}.AttributeTypes(ctx),
					},
				},
				Required:            true,
				Description:         "Cloud Logging configuration.",
				MarkdownDescription: "Cloud Logging configuration.",
			},
			"maintenance_window": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"day": schema.StringAttribute{
						Optional:            true,
						Description:         "Day of week for maintenance window. One of `MON`, `TUE`, `WED`, `THU`, `FRI`, `SAT`, `SUN`.",
						MarkdownDescription: "Day of week for maintenance window. One of `MON`, `TUE`, `WED`, `THU`, `FRI`, `SAT`, `SUN`.",
						Validators: []validator.String{
							mwDayValidator(),
						},
					},
					"hour": schema.Int64Attribute{
						Optional:            true,
						Description:         "Hour of day in UTC time zone (1-24) for maintenance window.",
						MarkdownDescription: "Hour of day in UTC time zone (1-24) for maintenance window.",
						Validators: []validator.Int64{
							mwHourValidator(),
						},
					},
					"type": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. If `WEEKLY`, day and hour must be specified.",
						MarkdownDescription: "Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. If `WEEKLY`, day and hour must be specified.",
						Validators: []validator.String{
							mwTypeValidator(),
						},
						Default: stringdefault.StaticString("ANYTIME"),
					},
				},
				CustomType: MaintenanceWindowType{
					ObjectType: types.ObjectType{
						AttrTypes: MaintenanceWindowValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Computed:            true,
				Description:         "Configuration of the window for maintenance operations.",
				MarkdownDescription: "Configuration of the window for maintenance operations.",
				Validators: []validator.Object{
					mwValidator(),
				},
				Default: maintenanceWindowDefault(),
			},
			"name": schema.StringAttribute{
				Required:            true,
				Description:         "Name of the cluster. The name is unique within the folder.",
				MarkdownDescription: "Name of the cluster. The name is unique within the folder.",
			},
			"network": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"security_group_ids": schema.SetAttribute{
						ElementType:         types.StringType,
						Optional:            true,
						Description:         "Network security groups.",
						MarkdownDescription: "Network security groups.",
					},
					"subnet_ids": schema.SetAttribute{
						ElementType:         types.StringType,
						Required:            true,
						Description:         "Network subnets.",
						MarkdownDescription: "Network subnets.",
						PlanModifiers: []planmodifier.Set{
							setplanmodifier.RequiresReplace(),
						},
					},
				},
				CustomType: NetworkType{
					ObjectType: types.ObjectType{
						AttrTypes: NetworkValue{}.AttributeTypes(ctx),
					},
				},
				Required:            true,
				Description:         "Network configuration.",
				MarkdownDescription: "Network configuration.",
			},
			"service_account_id": schema.StringAttribute{
				Required:            true,
				Description:         "The service account used by the cluster to access cloud resources.",
				MarkdownDescription: "The service account used by the cluster to access cloud resources.",
			},
			"status": schema.StringAttribute{
				Computed:            true,
				Description:         "Status of the cluster.",
				MarkdownDescription: "Status of the cluster.",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
		},
		Blocks: map[string]schema.Block{
			"timeouts": schema.SingleNestedBlock{
				CustomType: timeouts.Type{},
			},
		},
		Description: "Managed Spark cluster.",
	}
}

type ClusterModel struct {
	Config             ConfigValue            `tfsdk:"config"`
	CreatedAt          types.String           `tfsdk:"created_at"`
	DeletionProtection types.Bool             `tfsdk:"deletion_protection"`
	Description        types.String           `tfsdk:"description"`
	FolderId           types.String           `tfsdk:"folder_id"`
	Health             types.String           `tfsdk:"health"`
	Id                 types.String           `tfsdk:"id"`
	Labels             types.Map              `tfsdk:"labels"`
	Logging            LoggingValue           `tfsdk:"logging"`
	MaintenanceWindow  MaintenanceWindowValue `tfsdk:"maintenance_window"`
	Name               types.String           `tfsdk:"name"`
	Network            NetworkValue           `tfsdk:"network"`
	ServiceAccountId   types.String           `tfsdk:"service_account_id"`
	Status             types.String           `tfsdk:"status"`
	Timeouts           timeouts.Value         `tfsdk:"timeouts"`
}

var _ basetypes.ObjectTypable = ConfigType{}

type ConfigType struct {
	basetypes.ObjectType
}

func (t ConfigType) Equal(o attr.Type) bool {
	other, ok := o.(ConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ConfigType) String() string {
	return "ConfigType"
}

func (t ConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	dependenciesAttribute, ok := attributes["dependencies"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dependencies is missing from object`)

		return nil, diags
	}

	dependenciesVal, ok := dependenciesAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dependencies expected to be basetypes.ObjectValue, was: %T`, dependenciesAttribute))
	}

	historyServerAttribute, ok := attributes["history_server"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`history_server is missing from object`)

		return nil, diags
	}

	historyServerVal, ok := historyServerAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`history_server expected to be basetypes.ObjectValue, was: %T`, historyServerAttribute))
	}

	metastoreAttribute, ok := attributes["metastore"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metastore is missing from object`)

		return nil, diags
	}

	metastoreVal, ok := metastoreAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metastore expected to be basetypes.ObjectValue, was: %T`, metastoreAttribute))
	}

	resourcePoolsAttribute, ok := attributes["resource_pools"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`resource_pools is missing from object`)

		return nil, diags
	}

	resourcePoolsVal, ok := resourcePoolsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`resource_pools expected to be basetypes.ObjectValue, was: %T`, resourcePoolsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ConfigValue{
		Dependencies:  dependenciesVal,
		HistoryServer: historyServerVal,
		Metastore:     metastoreVal,
		ResourcePools: resourcePoolsVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewConfigValueNull() ConfigValue {
	return ConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewConfigValueUnknown() ConfigValue {
	return ConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ConfigValue Attribute Value",
				"While creating a ConfigValue value, a missing attribute value was detected. "+
					"A ConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ConfigValue Attribute Type",
				"While creating a ConfigValue value, an invalid attribute value was detected. "+
					"A ConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ConfigValue Attribute Value",
				"While creating a ConfigValue value, an extra attribute value was detected. "+
					"A ConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewConfigValueUnknown(), diags
	}

	dependenciesAttribute, ok := attributes["dependencies"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dependencies is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	dependenciesVal, ok := dependenciesAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dependencies expected to be basetypes.ObjectValue, was: %T`, dependenciesAttribute))
	}

	historyServerAttribute, ok := attributes["history_server"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`history_server is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	historyServerVal, ok := historyServerAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`history_server expected to be basetypes.ObjectValue, was: %T`, historyServerAttribute))
	}

	metastoreAttribute, ok := attributes["metastore"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metastore is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	metastoreVal, ok := metastoreAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metastore expected to be basetypes.ObjectValue, was: %T`, metastoreAttribute))
	}

	resourcePoolsAttribute, ok := attributes["resource_pools"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`resource_pools is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	resourcePoolsVal, ok := resourcePoolsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`resource_pools expected to be basetypes.ObjectValue, was: %T`, resourcePoolsAttribute))
	}

	if diags.HasError() {
		return NewConfigValueUnknown(), diags
	}

	return ConfigValue{
		Dependencies:  dependenciesVal,
		HistoryServer: historyServerVal,
		Metastore:     metastoreVal,
		ResourcePools: resourcePoolsVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ConfigValue {
	object, diags := NewConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewConfigValueMust(ConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ConfigType) ValueType(ctx context.Context) attr.Value {
	return ConfigValue{}
}

var _ basetypes.ObjectValuable = ConfigValue{}

type ConfigValue struct {
	Dependencies  basetypes.ObjectValue `tfsdk:"dependencies"`
	HistoryServer basetypes.ObjectValue `tfsdk:"history_server"`
	Metastore     basetypes.ObjectValue `tfsdk:"metastore"`
	ResourcePools basetypes.ObjectValue `tfsdk:"resource_pools"`
	state         attr.ValueState
}

func (v ConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["dependencies"] = basetypes.ObjectType{
		AttrTypes: DependenciesValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["history_server"] = basetypes.ObjectType{
		AttrTypes: HistoryServerValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["metastore"] = basetypes.ObjectType{
		AttrTypes: MetastoreValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["resource_pools"] = basetypes.ObjectType{
		AttrTypes: ResourcePoolsValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Dependencies.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dependencies"] = val

		val, err = v.HistoryServer.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["history_server"] = val

		val, err = v.Metastore.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["metastore"] = val

		val, err = v.ResourcePools.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["resource_pools"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ConfigValue) String() string {
	return "ConfigValue"
}

func (v ConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var dependencies basetypes.ObjectValue

	if v.Dependencies.IsNull() {
		dependencies = types.ObjectNull(
			DependenciesValue{}.AttributeTypes(ctx),
		)
	}

	if v.Dependencies.IsUnknown() {
		dependencies = types.ObjectUnknown(
			DependenciesValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Dependencies.IsNull() && !v.Dependencies.IsUnknown() {
		dependencies = types.ObjectValueMust(
			DependenciesValue{}.AttributeTypes(ctx),
			v.Dependencies.Attributes(),
		)
	}

	var historyServer basetypes.ObjectValue

	if v.HistoryServer.IsNull() {
		historyServer = types.ObjectNull(
			HistoryServerValue{}.AttributeTypes(ctx),
		)
	}

	if v.HistoryServer.IsUnknown() {
		historyServer = types.ObjectUnknown(
			HistoryServerValue{}.AttributeTypes(ctx),
		)
	}

	if !v.HistoryServer.IsNull() && !v.HistoryServer.IsUnknown() {
		historyServer = types.ObjectValueMust(
			HistoryServerValue{}.AttributeTypes(ctx),
			v.HistoryServer.Attributes(),
		)
	}

	var metastore basetypes.ObjectValue

	if v.Metastore.IsNull() {
		metastore = types.ObjectNull(
			MetastoreValue{}.AttributeTypes(ctx),
		)
	}

	if v.Metastore.IsUnknown() {
		metastore = types.ObjectUnknown(
			MetastoreValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Metastore.IsNull() && !v.Metastore.IsUnknown() {
		metastore = types.ObjectValueMust(
			MetastoreValue{}.AttributeTypes(ctx),
			v.Metastore.Attributes(),
		)
	}

	var resourcePools basetypes.ObjectValue

	if v.ResourcePools.IsNull() {
		resourcePools = types.ObjectNull(
			ResourcePoolsValue{}.AttributeTypes(ctx),
		)
	}

	if v.ResourcePools.IsUnknown() {
		resourcePools = types.ObjectUnknown(
			ResourcePoolsValue{}.AttributeTypes(ctx),
		)
	}

	if !v.ResourcePools.IsNull() && !v.ResourcePools.IsUnknown() {
		resourcePools = types.ObjectValueMust(
			ResourcePoolsValue{}.AttributeTypes(ctx),
			v.ResourcePools.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"dependencies": basetypes.ObjectType{
			AttrTypes: DependenciesValue{}.AttributeTypes(ctx),
		},
		"history_server": basetypes.ObjectType{
			AttrTypes: HistoryServerValue{}.AttributeTypes(ctx),
		},
		"metastore": basetypes.ObjectType{
			AttrTypes: MetastoreValue{}.AttributeTypes(ctx),
		},
		"resource_pools": basetypes.ObjectType{
			AttrTypes: ResourcePoolsValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"dependencies":   dependencies,
			"history_server": historyServer,
			"metastore":      metastore,
			"resource_pools": resourcePools,
		})

	return objVal, diags
}

func (v ConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(ConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Dependencies.Equal(other.Dependencies) {
		return false
	}

	if !v.HistoryServer.Equal(other.HistoryServer) {
		return false
	}

	if !v.Metastore.Equal(other.Metastore) {
		return false
	}

	if !v.ResourcePools.Equal(other.ResourcePools) {
		return false
	}

	return true
}

func (v ConfigValue) Type(ctx context.Context) attr.Type {
	return ConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"dependencies": basetypes.ObjectType{
			AttrTypes: DependenciesValue{}.AttributeTypes(ctx),
		},
		"history_server": basetypes.ObjectType{
			AttrTypes: HistoryServerValue{}.AttributeTypes(ctx),
		},
		"metastore": basetypes.ObjectType{
			AttrTypes: MetastoreValue{}.AttributeTypes(ctx),
		},
		"resource_pools": basetypes.ObjectType{
			AttrTypes: ResourcePoolsValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = DependenciesType{}

type DependenciesType struct {
	basetypes.ObjectType
}

func (t DependenciesType) Equal(o attr.Type) bool {
	other, ok := o.(DependenciesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DependenciesType) String() string {
	return "DependenciesType"
}

func (t DependenciesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	debPackagesAttribute, ok := attributes["deb_packages"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`deb_packages is missing from object`)

		return nil, diags
	}

	debPackagesVal, ok := debPackagesAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`deb_packages expected to be basetypes.SetValue, was: %T`, debPackagesAttribute))
	}

	pipPackagesAttribute, ok := attributes["pip_packages"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pip_packages is missing from object`)

		return nil, diags
	}

	pipPackagesVal, ok := pipPackagesAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pip_packages expected to be basetypes.SetValue, was: %T`, pipPackagesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DependenciesValue{
		DebPackages: debPackagesVal,
		PipPackages: pipPackagesVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewDependenciesValueNull() DependenciesValue {
	return DependenciesValue{
		state: attr.ValueStateNull,
	}
}

func NewDependenciesValueUnknown() DependenciesValue {
	return DependenciesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDependenciesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DependenciesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DependenciesValue Attribute Value",
				"While creating a DependenciesValue value, a missing attribute value was detected. "+
					"A DependenciesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DependenciesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DependenciesValue Attribute Type",
				"While creating a DependenciesValue value, an invalid attribute value was detected. "+
					"A DependenciesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DependenciesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DependenciesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DependenciesValue Attribute Value",
				"While creating a DependenciesValue value, an extra attribute value was detected. "+
					"A DependenciesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DependenciesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDependenciesValueUnknown(), diags
	}

	debPackagesAttribute, ok := attributes["deb_packages"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`deb_packages is missing from object`)

		return NewDependenciesValueUnknown(), diags
	}

	debPackagesVal, ok := debPackagesAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`deb_packages expected to be basetypes.SetValue, was: %T`, debPackagesAttribute))
	}

	pipPackagesAttribute, ok := attributes["pip_packages"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pip_packages is missing from object`)

		return NewDependenciesValueUnknown(), diags
	}

	pipPackagesVal, ok := pipPackagesAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pip_packages expected to be basetypes.SetValue, was: %T`, pipPackagesAttribute))
	}

	if diags.HasError() {
		return NewDependenciesValueUnknown(), diags
	}

	return DependenciesValue{
		DebPackages: debPackagesVal,
		PipPackages: pipPackagesVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewDependenciesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DependenciesValue {
	object, diags := NewDependenciesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDependenciesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DependenciesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDependenciesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDependenciesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDependenciesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDependenciesValueMust(DependenciesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DependenciesType) ValueType(ctx context.Context) attr.Value {
	return DependenciesValue{}
}

var _ basetypes.ObjectValuable = DependenciesValue{}

type DependenciesValue struct {
	DebPackages basetypes.SetValue `tfsdk:"deb_packages"`
	PipPackages basetypes.SetValue `tfsdk:"pip_packages"`
	state       attr.ValueState
}

func (v DependenciesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["deb_packages"] = basetypes.SetType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["pip_packages"] = basetypes.SetType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.DebPackages.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["deb_packages"] = val

		val, err = v.PipPackages.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["pip_packages"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DependenciesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DependenciesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DependenciesValue) String() string {
	return "DependenciesValue"
}

func (v DependenciesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var debPackagesVal basetypes.SetValue
	switch {
	case v.DebPackages.IsUnknown():
		debPackagesVal = types.SetUnknown(types.StringType)
	case v.DebPackages.IsNull():
		debPackagesVal = types.SetNull(types.StringType)
	default:
		var d diag.Diagnostics
		debPackagesVal, d = types.SetValue(types.StringType, v.DebPackages.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"deb_packages": basetypes.SetType{
				ElemType: types.StringType,
			},
			"pip_packages": basetypes.SetType{
				ElemType: types.StringType,
			},
		}), diags
	}

	var pipPackagesVal basetypes.SetValue
	switch {
	case v.PipPackages.IsUnknown():
		pipPackagesVal = types.SetUnknown(types.StringType)
	case v.PipPackages.IsNull():
		pipPackagesVal = types.SetNull(types.StringType)
	default:
		var d diag.Diagnostics
		pipPackagesVal, d = types.SetValue(types.StringType, v.PipPackages.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"deb_packages": basetypes.SetType{
				ElemType: types.StringType,
			},
			"pip_packages": basetypes.SetType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"deb_packages": basetypes.SetType{
			ElemType: types.StringType,
		},
		"pip_packages": basetypes.SetType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"deb_packages": debPackagesVal,
			"pip_packages": pipPackagesVal,
		})

	return objVal, diags
}

func (v DependenciesValue) Equal(o attr.Value) bool {
	other, ok := o.(DependenciesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DebPackages.Equal(other.DebPackages) {
		return false
	}

	if !v.PipPackages.Equal(other.PipPackages) {
		return false
	}

	return true
}

func (v DependenciesValue) Type(ctx context.Context) attr.Type {
	return DependenciesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DependenciesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"deb_packages": basetypes.SetType{
			ElemType: types.StringType,
		},
		"pip_packages": basetypes.SetType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = HistoryServerType{}

type HistoryServerType struct {
	basetypes.ObjectType
}

func (t HistoryServerType) Equal(o attr.Type) bool {
	other, ok := o.(HistoryServerType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t HistoryServerType) String() string {
	return "HistoryServerType"
}

func (t HistoryServerType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return HistoryServerValue{
		Enabled: enabledVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewHistoryServerValueNull() HistoryServerValue {
	return HistoryServerValue{
		state: attr.ValueStateNull,
	}
}

func NewHistoryServerValueUnknown() HistoryServerValue {
	return HistoryServerValue{
		state: attr.ValueStateUnknown,
	}
}

func NewHistoryServerValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (HistoryServerValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing HistoryServerValue Attribute Value",
				"While creating a HistoryServerValue value, a missing attribute value was detected. "+
					"A HistoryServerValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("HistoryServerValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid HistoryServerValue Attribute Type",
				"While creating a HistoryServerValue value, an invalid attribute value was detected. "+
					"A HistoryServerValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("HistoryServerValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("HistoryServerValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra HistoryServerValue Attribute Value",
				"While creating a HistoryServerValue value, an extra attribute value was detected. "+
					"A HistoryServerValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra HistoryServerValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewHistoryServerValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewHistoryServerValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	if diags.HasError() {
		return NewHistoryServerValueUnknown(), diags
	}

	return HistoryServerValue{
		Enabled: enabledVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewHistoryServerValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) HistoryServerValue {
	object, diags := NewHistoryServerValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewHistoryServerValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t HistoryServerType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewHistoryServerValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewHistoryServerValueUnknown(), nil
	}

	if in.IsNull() {
		return NewHistoryServerValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewHistoryServerValueMust(HistoryServerValue{}.AttributeTypes(ctx), attributes), nil
}

func (t HistoryServerType) ValueType(ctx context.Context) attr.Value {
	return HistoryServerValue{}
}

var _ basetypes.ObjectValuable = HistoryServerValue{}

type HistoryServerValue struct {
	Enabled basetypes.BoolValue `tfsdk:"enabled"`
	state   attr.ValueState
}

func (v HistoryServerValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v HistoryServerValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v HistoryServerValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v HistoryServerValue) String() string {
	return "HistoryServerValue"
}

func (v HistoryServerValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"enabled": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled": v.Enabled,
		})

	return objVal, diags
}

func (v HistoryServerValue) Equal(o attr.Value) bool {
	other, ok := o.(HistoryServerValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	return true
}

func (v HistoryServerValue) Type(ctx context.Context) attr.Type {
	return HistoryServerType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v HistoryServerValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = MetastoreType{}

type MetastoreType struct {
	basetypes.ObjectType
}

func (t MetastoreType) Equal(o attr.Type) bool {
	other, ok := o.(MetastoreType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MetastoreType) String() string {
	return "MetastoreType"
}

func (t MetastoreType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	clusterIdAttribute, ok := attributes["cluster_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cluster_id is missing from object`)

		return nil, diags
	}

	clusterIdVal, ok := clusterIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cluster_id expected to be basetypes.StringValue, was: %T`, clusterIdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MetastoreValue{
		ClusterId: clusterIdVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewMetastoreValueNull() MetastoreValue {
	return MetastoreValue{
		state: attr.ValueStateNull,
	}
}

func NewMetastoreValueUnknown() MetastoreValue {
	return MetastoreValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMetastoreValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MetastoreValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MetastoreValue Attribute Value",
				"While creating a MetastoreValue value, a missing attribute value was detected. "+
					"A MetastoreValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetastoreValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MetastoreValue Attribute Type",
				"While creating a MetastoreValue value, an invalid attribute value was detected. "+
					"A MetastoreValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetastoreValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MetastoreValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MetastoreValue Attribute Value",
				"While creating a MetastoreValue value, an extra attribute value was detected. "+
					"A MetastoreValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MetastoreValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMetastoreValueUnknown(), diags
	}

	clusterIdAttribute, ok := attributes["cluster_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cluster_id is missing from object`)

		return NewMetastoreValueUnknown(), diags
	}

	clusterIdVal, ok := clusterIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cluster_id expected to be basetypes.StringValue, was: %T`, clusterIdAttribute))
	}

	if diags.HasError() {
		return NewMetastoreValueUnknown(), diags
	}

	return MetastoreValue{
		ClusterId: clusterIdVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewMetastoreValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MetastoreValue {
	object, diags := NewMetastoreValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMetastoreValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MetastoreType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMetastoreValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMetastoreValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMetastoreValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMetastoreValueMust(MetastoreValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MetastoreType) ValueType(ctx context.Context) attr.Value {
	return MetastoreValue{}
}

var _ basetypes.ObjectValuable = MetastoreValue{}

type MetastoreValue struct {
	ClusterId basetypes.StringValue `tfsdk:"cluster_id"`
	state     attr.ValueState
}

func (v MetastoreValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["cluster_id"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.ClusterId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cluster_id"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MetastoreValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MetastoreValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MetastoreValue) String() string {
	return "MetastoreValue"
}

func (v MetastoreValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"cluster_id": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"cluster_id": v.ClusterId,
		})

	return objVal, diags
}

func (v MetastoreValue) Equal(o attr.Value) bool {
	other, ok := o.(MetastoreValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ClusterId.Equal(other.ClusterId) {
		return false
	}

	return true
}

func (v MetastoreValue) Type(ctx context.Context) attr.Type {
	return MetastoreType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MetastoreValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"cluster_id": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ResourcePoolsType{}

type ResourcePoolsType struct {
	basetypes.ObjectType
}

func (t ResourcePoolsType) Equal(o attr.Type) bool {
	other, ok := o.(ResourcePoolsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ResourcePoolsType) String() string {
	return "ResourcePoolsType"
}

func (t ResourcePoolsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	driverAttribute, ok := attributes["driver"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`driver is missing from object`)

		return nil, diags
	}

	driverVal, ok := driverAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`driver expected to be basetypes.ObjectValue, was: %T`, driverAttribute))
	}

	executorAttribute, ok := attributes["executor"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`executor is missing from object`)

		return nil, diags
	}

	executorVal, ok := executorAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`executor expected to be basetypes.ObjectValue, was: %T`, executorAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ResourcePoolsValue{
		Driver:   driverVal,
		Executor: executorVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewResourcePoolsValueNull() ResourcePoolsValue {
	return ResourcePoolsValue{
		state: attr.ValueStateNull,
	}
}

func NewResourcePoolsValueUnknown() ResourcePoolsValue {
	return ResourcePoolsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewResourcePoolsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ResourcePoolsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ResourcePoolsValue Attribute Value",
				"While creating a ResourcePoolsValue value, a missing attribute value was detected. "+
					"A ResourcePoolsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ResourcePoolsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ResourcePoolsValue Attribute Type",
				"While creating a ResourcePoolsValue value, an invalid attribute value was detected. "+
					"A ResourcePoolsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ResourcePoolsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ResourcePoolsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ResourcePoolsValue Attribute Value",
				"While creating a ResourcePoolsValue value, an extra attribute value was detected. "+
					"A ResourcePoolsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ResourcePoolsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewResourcePoolsValueUnknown(), diags
	}

	driverAttribute, ok := attributes["driver"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`driver is missing from object`)

		return NewResourcePoolsValueUnknown(), diags
	}

	driverVal, ok := driverAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`driver expected to be basetypes.ObjectValue, was: %T`, driverAttribute))
	}

	executorAttribute, ok := attributes["executor"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`executor is missing from object`)

		return NewResourcePoolsValueUnknown(), diags
	}

	executorVal, ok := executorAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`executor expected to be basetypes.ObjectValue, was: %T`, executorAttribute))
	}

	if diags.HasError() {
		return NewResourcePoolsValueUnknown(), diags
	}

	return ResourcePoolsValue{
		Driver:   driverVal,
		Executor: executorVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewResourcePoolsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ResourcePoolsValue {
	object, diags := NewResourcePoolsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewResourcePoolsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ResourcePoolsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewResourcePoolsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewResourcePoolsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewResourcePoolsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewResourcePoolsValueMust(ResourcePoolsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ResourcePoolsType) ValueType(ctx context.Context) attr.Value {
	return ResourcePoolsValue{}
}

var _ basetypes.ObjectValuable = ResourcePoolsValue{}

type ResourcePoolsValue struct {
	Driver   basetypes.ObjectValue `tfsdk:"driver"`
	Executor basetypes.ObjectValue `tfsdk:"executor"`
	state    attr.ValueState
}

func (v ResourcePoolsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["driver"] = basetypes.ObjectType{
		AttrTypes: DriverValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["executor"] = basetypes.ObjectType{
		AttrTypes: ExecutorValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Driver.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["driver"] = val

		val, err = v.Executor.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["executor"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ResourcePoolsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ResourcePoolsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ResourcePoolsValue) String() string {
	return "ResourcePoolsValue"
}

func (v ResourcePoolsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var driver basetypes.ObjectValue

	if v.Driver.IsNull() {
		driver = types.ObjectNull(
			DriverValue{}.AttributeTypes(ctx),
		)
	}

	if v.Driver.IsUnknown() {
		driver = types.ObjectUnknown(
			DriverValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Driver.IsNull() && !v.Driver.IsUnknown() {
		driver = types.ObjectValueMust(
			DriverValue{}.AttributeTypes(ctx),
			v.Driver.Attributes(),
		)
	}

	var executor basetypes.ObjectValue

	if v.Executor.IsNull() {
		executor = types.ObjectNull(
			ExecutorValue{}.AttributeTypes(ctx),
		)
	}

	if v.Executor.IsUnknown() {
		executor = types.ObjectUnknown(
			ExecutorValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Executor.IsNull() && !v.Executor.IsUnknown() {
		executor = types.ObjectValueMust(
			ExecutorValue{}.AttributeTypes(ctx),
			v.Executor.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"driver": basetypes.ObjectType{
			AttrTypes: DriverValue{}.AttributeTypes(ctx),
		},
		"executor": basetypes.ObjectType{
			AttrTypes: ExecutorValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"driver":   driver,
			"executor": executor,
		})

	return objVal, diags
}

func (v ResourcePoolsValue) Equal(o attr.Value) bool {
	other, ok := o.(ResourcePoolsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Driver.Equal(other.Driver) {
		return false
	}

	if !v.Executor.Equal(other.Executor) {
		return false
	}

	return true
}

func (v ResourcePoolsValue) Type(ctx context.Context) attr.Type {
	return ResourcePoolsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ResourcePoolsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"driver": basetypes.ObjectType{
			AttrTypes: DriverValue{}.AttributeTypes(ctx),
		},
		"executor": basetypes.ObjectType{
			AttrTypes: ExecutorValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = DriverType{}

type DriverType struct {
	basetypes.ObjectType
}

func (t DriverType) Equal(o attr.Type) bool {
	other, ok := o.(DriverType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DriverType) String() string {
	return "DriverType"
}

func (t DriverType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	maxSizeAttribute, ok := attributes["max_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_size is missing from object`)

		return nil, diags
	}

	maxSizeVal, ok := maxSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_size expected to be basetypes.Int64Value, was: %T`, maxSizeAttribute))
	}

	minSizeAttribute, ok := attributes["min_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_size is missing from object`)

		return nil, diags
	}

	minSizeVal, ok := minSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_size expected to be basetypes.Int64Value, was: %T`, minSizeAttribute))
	}

	resourcePresetIdAttribute, ok := attributes["resource_preset_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`resource_preset_id is missing from object`)

		return nil, diags
	}

	resourcePresetIdVal, ok := resourcePresetIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`resource_preset_id expected to be basetypes.StringValue, was: %T`, resourcePresetIdAttribute))
	}

	sizeAttribute, ok := attributes["size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`size is missing from object`)

		return nil, diags
	}

	sizeVal, ok := sizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`size expected to be basetypes.Int64Value, was: %T`, sizeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DriverValue{
		MaxSize:          maxSizeVal,
		MinSize:          minSizeVal,
		ResourcePresetId: resourcePresetIdVal,
		Size:             sizeVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewDriverValueNull() DriverValue {
	return DriverValue{
		state: attr.ValueStateNull,
	}
}

func NewDriverValueUnknown() DriverValue {
	return DriverValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDriverValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DriverValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DriverValue Attribute Value",
				"While creating a DriverValue value, a missing attribute value was detected. "+
					"A DriverValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DriverValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DriverValue Attribute Type",
				"While creating a DriverValue value, an invalid attribute value was detected. "+
					"A DriverValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DriverValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DriverValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DriverValue Attribute Value",
				"While creating a DriverValue value, an extra attribute value was detected. "+
					"A DriverValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DriverValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDriverValueUnknown(), diags
	}

	maxSizeAttribute, ok := attributes["max_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_size is missing from object`)

		return NewDriverValueUnknown(), diags
	}

	maxSizeVal, ok := maxSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_size expected to be basetypes.Int64Value, was: %T`, maxSizeAttribute))
	}

	minSizeAttribute, ok := attributes["min_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_size is missing from object`)

		return NewDriverValueUnknown(), diags
	}

	minSizeVal, ok := minSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_size expected to be basetypes.Int64Value, was: %T`, minSizeAttribute))
	}

	resourcePresetIdAttribute, ok := attributes["resource_preset_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`resource_preset_id is missing from object`)

		return NewDriverValueUnknown(), diags
	}

	resourcePresetIdVal, ok := resourcePresetIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`resource_preset_id expected to be basetypes.StringValue, was: %T`, resourcePresetIdAttribute))
	}

	sizeAttribute, ok := attributes["size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`size is missing from object`)

		return NewDriverValueUnknown(), diags
	}

	sizeVal, ok := sizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`size expected to be basetypes.Int64Value, was: %T`, sizeAttribute))
	}

	if diags.HasError() {
		return NewDriverValueUnknown(), diags
	}

	return DriverValue{
		MaxSize:          maxSizeVal,
		MinSize:          minSizeVal,
		ResourcePresetId: resourcePresetIdVal,
		Size:             sizeVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewDriverValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DriverValue {
	object, diags := NewDriverValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDriverValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DriverType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDriverValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDriverValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDriverValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDriverValueMust(DriverValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DriverType) ValueType(ctx context.Context) attr.Value {
	return DriverValue{}
}

var _ basetypes.ObjectValuable = DriverValue{}

type DriverValue struct {
	MaxSize          basetypes.Int64Value  `tfsdk:"max_size"`
	MinSize          basetypes.Int64Value  `tfsdk:"min_size"`
	ResourcePresetId basetypes.StringValue `tfsdk:"resource_preset_id"`
	Size             basetypes.Int64Value  `tfsdk:"size"`
	state            attr.ValueState
}

func (v DriverValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["max_size"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["min_size"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["resource_preset_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["size"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.MaxSize.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_size"] = val

		val, err = v.MinSize.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["min_size"] = val

		val, err = v.ResourcePresetId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["resource_preset_id"] = val

		val, err = v.Size.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["size"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DriverValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DriverValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DriverValue) String() string {
	return "DriverValue"
}

func (v DriverValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"max_size":           basetypes.Int64Type{},
		"min_size":           basetypes.Int64Type{},
		"resource_preset_id": basetypes.StringType{},
		"size":               basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"max_size":           v.MaxSize,
			"min_size":           v.MinSize,
			"resource_preset_id": v.ResourcePresetId,
			"size":               v.Size,
		})

	return objVal, diags
}

func (v DriverValue) Equal(o attr.Value) bool {
	other, ok := o.(DriverValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.MaxSize.Equal(other.MaxSize) {
		return false
	}

	if !v.MinSize.Equal(other.MinSize) {
		return false
	}

	if !v.ResourcePresetId.Equal(other.ResourcePresetId) {
		return false
	}

	if !v.Size.Equal(other.Size) {
		return false
	}

	return true
}

func (v DriverValue) Type(ctx context.Context) attr.Type {
	return DriverType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DriverValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"max_size":           basetypes.Int64Type{},
		"min_size":           basetypes.Int64Type{},
		"resource_preset_id": basetypes.StringType{},
		"size":               basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = ExecutorType{}

type ExecutorType struct {
	basetypes.ObjectType
}

func (t ExecutorType) Equal(o attr.Type) bool {
	other, ok := o.(ExecutorType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ExecutorType) String() string {
	return "ExecutorType"
}

func (t ExecutorType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	maxSizeAttribute, ok := attributes["max_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_size is missing from object`)

		return nil, diags
	}

	maxSizeVal, ok := maxSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_size expected to be basetypes.Int64Value, was: %T`, maxSizeAttribute))
	}

	minSizeAttribute, ok := attributes["min_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_size is missing from object`)

		return nil, diags
	}

	minSizeVal, ok := minSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_size expected to be basetypes.Int64Value, was: %T`, minSizeAttribute))
	}

	resourcePresetIdAttribute, ok := attributes["resource_preset_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`resource_preset_id is missing from object`)

		return nil, diags
	}

	resourcePresetIdVal, ok := resourcePresetIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`resource_preset_id expected to be basetypes.StringValue, was: %T`, resourcePresetIdAttribute))
	}

	sizeAttribute, ok := attributes["size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`size is missing from object`)

		return nil, diags
	}

	sizeVal, ok := sizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`size expected to be basetypes.Int64Value, was: %T`, sizeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ExecutorValue{
		MaxSize:          maxSizeVal,
		MinSize:          minSizeVal,
		ResourcePresetId: resourcePresetIdVal,
		Size:             sizeVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewExecutorValueNull() ExecutorValue {
	return ExecutorValue{
		state: attr.ValueStateNull,
	}
}

func NewExecutorValueUnknown() ExecutorValue {
	return ExecutorValue{
		state: attr.ValueStateUnknown,
	}
}

func NewExecutorValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ExecutorValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ExecutorValue Attribute Value",
				"While creating a ExecutorValue value, a missing attribute value was detected. "+
					"A ExecutorValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ExecutorValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ExecutorValue Attribute Type",
				"While creating a ExecutorValue value, an invalid attribute value was detected. "+
					"A ExecutorValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ExecutorValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ExecutorValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ExecutorValue Attribute Value",
				"While creating a ExecutorValue value, an extra attribute value was detected. "+
					"A ExecutorValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ExecutorValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewExecutorValueUnknown(), diags
	}

	maxSizeAttribute, ok := attributes["max_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_size is missing from object`)

		return NewExecutorValueUnknown(), diags
	}

	maxSizeVal, ok := maxSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_size expected to be basetypes.Int64Value, was: %T`, maxSizeAttribute))
	}

	minSizeAttribute, ok := attributes["min_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_size is missing from object`)

		return NewExecutorValueUnknown(), diags
	}

	minSizeVal, ok := minSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_size expected to be basetypes.Int64Value, was: %T`, minSizeAttribute))
	}

	resourcePresetIdAttribute, ok := attributes["resource_preset_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`resource_preset_id is missing from object`)

		return NewExecutorValueUnknown(), diags
	}

	resourcePresetIdVal, ok := resourcePresetIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`resource_preset_id expected to be basetypes.StringValue, was: %T`, resourcePresetIdAttribute))
	}

	sizeAttribute, ok := attributes["size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`size is missing from object`)

		return NewExecutorValueUnknown(), diags
	}

	sizeVal, ok := sizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`size expected to be basetypes.Int64Value, was: %T`, sizeAttribute))
	}

	if diags.HasError() {
		return NewExecutorValueUnknown(), diags
	}

	return ExecutorValue{
		MaxSize:          maxSizeVal,
		MinSize:          minSizeVal,
		ResourcePresetId: resourcePresetIdVal,
		Size:             sizeVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewExecutorValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ExecutorValue {
	object, diags := NewExecutorValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewExecutorValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ExecutorType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewExecutorValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewExecutorValueUnknown(), nil
	}

	if in.IsNull() {
		return NewExecutorValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewExecutorValueMust(ExecutorValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ExecutorType) ValueType(ctx context.Context) attr.Value {
	return ExecutorValue{}
}

var _ basetypes.ObjectValuable = ExecutorValue{}

type ExecutorValue struct {
	MaxSize          basetypes.Int64Value  `tfsdk:"max_size"`
	MinSize          basetypes.Int64Value  `tfsdk:"min_size"`
	ResourcePresetId basetypes.StringValue `tfsdk:"resource_preset_id"`
	Size             basetypes.Int64Value  `tfsdk:"size"`
	state            attr.ValueState
}

func (v ExecutorValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["max_size"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["min_size"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["resource_preset_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["size"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.MaxSize.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_size"] = val

		val, err = v.MinSize.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["min_size"] = val

		val, err = v.ResourcePresetId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["resource_preset_id"] = val

		val, err = v.Size.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["size"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ExecutorValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ExecutorValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ExecutorValue) String() string {
	return "ExecutorValue"
}

func (v ExecutorValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"max_size":           basetypes.Int64Type{},
		"min_size":           basetypes.Int64Type{},
		"resource_preset_id": basetypes.StringType{},
		"size":               basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"max_size":           v.MaxSize,
			"min_size":           v.MinSize,
			"resource_preset_id": v.ResourcePresetId,
			"size":               v.Size,
		})

	return objVal, diags
}

func (v ExecutorValue) Equal(o attr.Value) bool {
	other, ok := o.(ExecutorValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.MaxSize.Equal(other.MaxSize) {
		return false
	}

	if !v.MinSize.Equal(other.MinSize) {
		return false
	}

	if !v.ResourcePresetId.Equal(other.ResourcePresetId) {
		return false
	}

	if !v.Size.Equal(other.Size) {
		return false
	}

	return true
}

func (v ExecutorValue) Type(ctx context.Context) attr.Type {
	return ExecutorType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ExecutorValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"max_size":           basetypes.Int64Type{},
		"min_size":           basetypes.Int64Type{},
		"resource_preset_id": basetypes.StringType{},
		"size":               basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = LoggingType{}

type LoggingType struct {
	basetypes.ObjectType
}

func (t LoggingType) Equal(o attr.Type) bool {
	other, ok := o.(LoggingType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t LoggingType) String() string {
	return "LoggingType"
}

func (t LoggingType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	folderIdAttribute, ok := attributes["folder_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`folder_id is missing from object`)

		return nil, diags
	}

	folderIdVal, ok := folderIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`folder_id expected to be basetypes.StringValue, was: %T`, folderIdAttribute))
	}

	logGroupIdAttribute, ok := attributes["log_group_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`log_group_id is missing from object`)

		return nil, diags
	}

	logGroupIdVal, ok := logGroupIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`log_group_id expected to be basetypes.StringValue, was: %T`, logGroupIdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return LoggingValue{
		Enabled:    enabledVal,
		FolderId:   folderIdVal,
		LogGroupId: logGroupIdVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewLoggingValueNull() LoggingValue {
	return LoggingValue{
		state: attr.ValueStateNull,
	}
}

func NewLoggingValueUnknown() LoggingValue {
	return LoggingValue{
		state: attr.ValueStateUnknown,
	}
}

func NewLoggingValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (LoggingValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing LoggingValue Attribute Value",
				"While creating a LoggingValue value, a missing attribute value was detected. "+
					"A LoggingValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LoggingValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid LoggingValue Attribute Type",
				"While creating a LoggingValue value, an invalid attribute value was detected. "+
					"A LoggingValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LoggingValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("LoggingValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra LoggingValue Attribute Value",
				"While creating a LoggingValue value, an extra attribute value was detected. "+
					"A LoggingValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra LoggingValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewLoggingValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewLoggingValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	folderIdAttribute, ok := attributes["folder_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`folder_id is missing from object`)

		return NewLoggingValueUnknown(), diags
	}

	folderIdVal, ok := folderIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`folder_id expected to be basetypes.StringValue, was: %T`, folderIdAttribute))
	}

	logGroupIdAttribute, ok := attributes["log_group_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`log_group_id is missing from object`)

		return NewLoggingValueUnknown(), diags
	}

	logGroupIdVal, ok := logGroupIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`log_group_id expected to be basetypes.StringValue, was: %T`, logGroupIdAttribute))
	}

	if diags.HasError() {
		return NewLoggingValueUnknown(), diags
	}

	return LoggingValue{
		Enabled:    enabledVal,
		FolderId:   folderIdVal,
		LogGroupId: logGroupIdVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewLoggingValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) LoggingValue {
	object, diags := NewLoggingValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewLoggingValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t LoggingType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewLoggingValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewLoggingValueUnknown(), nil
	}

	if in.IsNull() {
		return NewLoggingValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewLoggingValueMust(LoggingValue{}.AttributeTypes(ctx), attributes), nil
}

func (t LoggingType) ValueType(ctx context.Context) attr.Value {
	return LoggingValue{}
}

var _ basetypes.ObjectValuable = LoggingValue{}

type LoggingValue struct {
	Enabled    basetypes.BoolValue   `tfsdk:"enabled"`
	FolderId   basetypes.StringValue `tfsdk:"folder_id"`
	LogGroupId basetypes.StringValue `tfsdk:"log_group_id"`
	state      attr.ValueState
}

func (v LoggingValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["folder_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["log_group_id"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.FolderId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["folder_id"] = val

		val, err = v.LogGroupId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["log_group_id"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v LoggingValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v LoggingValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v LoggingValue) String() string {
	return "LoggingValue"
}

func (v LoggingValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"enabled":      basetypes.BoolType{},
		"folder_id":    basetypes.StringType{},
		"log_group_id": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled":      v.Enabled,
			"folder_id":    v.FolderId,
			"log_group_id": v.LogGroupId,
		})

	return objVal, diags
}

func (v LoggingValue) Equal(o attr.Value) bool {
	other, ok := o.(LoggingValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.FolderId.Equal(other.FolderId) {
		return false
	}

	if !v.LogGroupId.Equal(other.LogGroupId) {
		return false
	}

	return true
}

func (v LoggingValue) Type(ctx context.Context) attr.Type {
	return LoggingType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v LoggingValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled":      basetypes.BoolType{},
		"folder_id":    basetypes.StringType{},
		"log_group_id": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = MaintenanceWindowType{}

type MaintenanceWindowType struct {
	basetypes.ObjectType
}

func (t MaintenanceWindowType) Equal(o attr.Type) bool {
	other, ok := o.(MaintenanceWindowType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MaintenanceWindowType) String() string {
	return "MaintenanceWindowType"
}

func (t MaintenanceWindowType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	dayAttribute, ok := attributes["day"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`day is missing from object`)

		return nil, diags
	}

	dayVal, ok := dayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`day expected to be basetypes.StringValue, was: %T`, dayAttribute))
	}

	hourAttribute, ok := attributes["hour"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hour is missing from object`)

		return nil, diags
	}

	hourVal, ok := hourAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hour expected to be basetypes.Int64Value, was: %T`, hourAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MaintenanceWindowValue{
		Day:                   dayVal,
		Hour:                  hourVal,
		MaintenanceWindowType: typeVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewMaintenanceWindowValueNull() MaintenanceWindowValue {
	return MaintenanceWindowValue{
		state: attr.ValueStateNull,
	}
}

func NewMaintenanceWindowValueUnknown() MaintenanceWindowValue {
	return MaintenanceWindowValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMaintenanceWindowValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MaintenanceWindowValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MaintenanceWindowValue Attribute Value",
				"While creating a MaintenanceWindowValue value, a missing attribute value was detected. "+
					"A MaintenanceWindowValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MaintenanceWindowValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MaintenanceWindowValue Attribute Type",
				"While creating a MaintenanceWindowValue value, an invalid attribute value was detected. "+
					"A MaintenanceWindowValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MaintenanceWindowValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MaintenanceWindowValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MaintenanceWindowValue Attribute Value",
				"While creating a MaintenanceWindowValue value, an extra attribute value was detected. "+
					"A MaintenanceWindowValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MaintenanceWindowValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMaintenanceWindowValueUnknown(), diags
	}

	dayAttribute, ok := attributes["day"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`day is missing from object`)

		return NewMaintenanceWindowValueUnknown(), diags
	}

	dayVal, ok := dayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`day expected to be basetypes.StringValue, was: %T`, dayAttribute))
	}

	hourAttribute, ok := attributes["hour"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hour is missing from object`)

		return NewMaintenanceWindowValueUnknown(), diags
	}

	hourVal, ok := hourAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hour expected to be basetypes.Int64Value, was: %T`, hourAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewMaintenanceWindowValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewMaintenanceWindowValueUnknown(), diags
	}

	return MaintenanceWindowValue{
		Day:                   dayVal,
		Hour:                  hourVal,
		MaintenanceWindowType: typeVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewMaintenanceWindowValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MaintenanceWindowValue {
	object, diags := NewMaintenanceWindowValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMaintenanceWindowValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MaintenanceWindowType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMaintenanceWindowValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMaintenanceWindowValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMaintenanceWindowValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMaintenanceWindowValueMust(MaintenanceWindowValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MaintenanceWindowType) ValueType(ctx context.Context) attr.Value {
	return MaintenanceWindowValue{}
}

var _ basetypes.ObjectValuable = MaintenanceWindowValue{}

type MaintenanceWindowValue struct {
	Day                   basetypes.StringValue `tfsdk:"day"`
	Hour                  basetypes.Int64Value  `tfsdk:"hour"`
	MaintenanceWindowType basetypes.StringValue `tfsdk:"type"`
	state                 attr.ValueState
}

func (v MaintenanceWindowValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["day"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["hour"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Day.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["day"] = val

		val, err = v.Hour.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["hour"] = val

		val, err = v.MaintenanceWindowType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MaintenanceWindowValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MaintenanceWindowValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MaintenanceWindowValue) String() string {
	return "MaintenanceWindowValue"
}

func (v MaintenanceWindowValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"day":  basetypes.StringType{},
		"hour": basetypes.Int64Type{},
		"type": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"day":  v.Day,
			"hour": v.Hour,
			"type": v.MaintenanceWindowType,
		})

	return objVal, diags
}

func (v MaintenanceWindowValue) Equal(o attr.Value) bool {
	other, ok := o.(MaintenanceWindowValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Day.Equal(other.Day) {
		return false
	}

	if !v.Hour.Equal(other.Hour) {
		return false
	}

	if !v.MaintenanceWindowType.Equal(other.MaintenanceWindowType) {
		return false
	}

	return true
}

func (v MaintenanceWindowValue) Type(ctx context.Context) attr.Type {
	return MaintenanceWindowType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MaintenanceWindowValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"day":  basetypes.StringType{},
		"hour": basetypes.Int64Type{},
		"type": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = NetworkType{}

type NetworkType struct {
	basetypes.ObjectType
}

func (t NetworkType) Equal(o attr.Type) bool {
	other, ok := o.(NetworkType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t NetworkType) String() string {
	return "NetworkType"
}

func (t NetworkType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	securityGroupIdsAttribute, ok := attributes["security_group_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`security_group_ids is missing from object`)

		return nil, diags
	}

	securityGroupIdsVal, ok := securityGroupIdsAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`security_group_ids expected to be basetypes.SetValue, was: %T`, securityGroupIdsAttribute))
	}

	subnetIdsAttribute, ok := attributes["subnet_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet_ids is missing from object`)

		return nil, diags
	}

	subnetIdsVal, ok := subnetIdsAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet_ids expected to be basetypes.SetValue, was: %T`, subnetIdsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return NetworkValue{
		SecurityGroupIds: securityGroupIdsVal,
		SubnetIds:        subnetIdsVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewNetworkValueNull() NetworkValue {
	return NetworkValue{
		state: attr.ValueStateNull,
	}
}

func NewNetworkValueUnknown() NetworkValue {
	return NetworkValue{
		state: attr.ValueStateUnknown,
	}
}

func NewNetworkValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (NetworkValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing NetworkValue Attribute Value",
				"While creating a NetworkValue value, a missing attribute value was detected. "+
					"A NetworkValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NetworkValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid NetworkValue Attribute Type",
				"While creating a NetworkValue value, an invalid attribute value was detected. "+
					"A NetworkValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NetworkValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("NetworkValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra NetworkValue Attribute Value",
				"While creating a NetworkValue value, an extra attribute value was detected. "+
					"A NetworkValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra NetworkValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewNetworkValueUnknown(), diags
	}

	securityGroupIdsAttribute, ok := attributes["security_group_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`security_group_ids is missing from object`)

		return NewNetworkValueUnknown(), diags
	}

	securityGroupIdsVal, ok := securityGroupIdsAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`security_group_ids expected to be basetypes.SetValue, was: %T`, securityGroupIdsAttribute))
	}

	subnetIdsAttribute, ok := attributes["subnet_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet_ids is missing from object`)

		return NewNetworkValueUnknown(), diags
	}

	subnetIdsVal, ok := subnetIdsAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet_ids expected to be basetypes.SetValue, was: %T`, subnetIdsAttribute))
	}

	if diags.HasError() {
		return NewNetworkValueUnknown(), diags
	}

	return NetworkValue{
		SecurityGroupIds: securityGroupIdsVal,
		SubnetIds:        subnetIdsVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewNetworkValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) NetworkValue {
	object, diags := NewNetworkValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewNetworkValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t NetworkType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewNetworkValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewNetworkValueUnknown(), nil
	}

	if in.IsNull() {
		return NewNetworkValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewNetworkValueMust(NetworkValue{}.AttributeTypes(ctx), attributes), nil
}

func (t NetworkType) ValueType(ctx context.Context) attr.Value {
	return NetworkValue{}
}

var _ basetypes.ObjectValuable = NetworkValue{}

type NetworkValue struct {
	SecurityGroupIds basetypes.SetValue `tfsdk:"security_group_ids"`
	SubnetIds        basetypes.SetValue `tfsdk:"subnet_ids"`
	state            attr.ValueState
}

func (v NetworkValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["security_group_ids"] = basetypes.SetType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["subnet_ids"] = basetypes.SetType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.SecurityGroupIds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["security_group_ids"] = val

		val, err = v.SubnetIds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subnet_ids"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v NetworkValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v NetworkValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v NetworkValue) String() string {
	return "NetworkValue"
}

func (v NetworkValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var securityGroupIdsVal basetypes.SetValue
	switch {
	case v.SecurityGroupIds.IsUnknown():
		securityGroupIdsVal = types.SetUnknown(types.StringType)
	case v.SecurityGroupIds.IsNull():
		securityGroupIdsVal = types.SetNull(types.StringType)
	default:
		var d diag.Diagnostics
		securityGroupIdsVal, d = types.SetValue(types.StringType, v.SecurityGroupIds.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"security_group_ids": basetypes.SetType{
				ElemType: types.StringType,
			},
			"subnet_ids": basetypes.SetType{
				ElemType: types.StringType,
			},
		}), diags
	}

	var subnetIdsVal basetypes.SetValue
	switch {
	case v.SubnetIds.IsUnknown():
		subnetIdsVal = types.SetUnknown(types.StringType)
	case v.SubnetIds.IsNull():
		subnetIdsVal = types.SetNull(types.StringType)
	default:
		var d diag.Diagnostics
		subnetIdsVal, d = types.SetValue(types.StringType, v.SubnetIds.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"security_group_ids": basetypes.SetType{
				ElemType: types.StringType,
			},
			"subnet_ids": basetypes.SetType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"security_group_ids": basetypes.SetType{
			ElemType: types.StringType,
		},
		"subnet_ids": basetypes.SetType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"security_group_ids": securityGroupIdsVal,
			"subnet_ids":         subnetIdsVal,
		})

	return objVal, diags
}

func (v NetworkValue) Equal(o attr.Value) bool {
	other, ok := o.(NetworkValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.SecurityGroupIds.Equal(other.SecurityGroupIds) {
		return false
	}

	if !v.SubnetIds.Equal(other.SubnetIds) {
		return false
	}

	return true
}

func (v NetworkValue) Type(ctx context.Context) attr.Type {
	return NetworkType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v NetworkValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"security_group_ids": basetypes.SetType{
			ElemType: types.StringType,
		},
		"subnet_ids": basetypes.SetType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = TimeoutsType{}

type TimeoutsType struct {
	basetypes.ObjectType
}

func (t TimeoutsType) Equal(o attr.Type) bool {
	other, ok := o.(TimeoutsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TimeoutsType) String() string {
	return "TimeoutsType"
}

func (t TimeoutsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	if diags.HasError() {
		return nil, diags
	}

	return TimeoutsValue{
		state: attr.ValueStateKnown,
	}, diags
}

func NewTimeoutsValueNull() TimeoutsValue {
	return TimeoutsValue{
		state: attr.ValueStateNull,
	}
}

func NewTimeoutsValueUnknown() TimeoutsValue {
	return TimeoutsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTimeoutsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TimeoutsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TimeoutsValue Attribute Value",
				"While creating a TimeoutsValue value, a missing attribute value was detected. "+
					"A TimeoutsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TimeoutsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TimeoutsValue Attribute Type",
				"While creating a TimeoutsValue value, an invalid attribute value was detected. "+
					"A TimeoutsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TimeoutsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TimeoutsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TimeoutsValue Attribute Value",
				"While creating a TimeoutsValue value, an extra attribute value was detected. "+
					"A TimeoutsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TimeoutsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTimeoutsValueUnknown(), diags
	}

	if diags.HasError() {
		return NewTimeoutsValueUnknown(), diags
	}

	return TimeoutsValue{
		state: attr.ValueStateKnown,
	}, diags
}

func NewTimeoutsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TimeoutsValue {
	object, diags := NewTimeoutsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTimeoutsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TimeoutsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTimeoutsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTimeoutsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTimeoutsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTimeoutsValueMust(TimeoutsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TimeoutsType) ValueType(ctx context.Context) attr.Value {
	return TimeoutsValue{}
}

var _ basetypes.ObjectValuable = TimeoutsValue{}

type TimeoutsValue struct {
	state attr.ValueState
}

func (v TimeoutsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 0)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 0)

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TimeoutsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TimeoutsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TimeoutsValue) String() string {
	return "TimeoutsValue"
}

func (v TimeoutsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{})

	return objVal, diags
}

func (v TimeoutsValue) Equal(o attr.Value) bool {
	other, ok := o.(TimeoutsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	return true
}

func (v TimeoutsValue) Type(ctx context.Context) attr.Type {
	return TimeoutsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TimeoutsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{}
}
